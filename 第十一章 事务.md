# 事务

事务是代表单个工作单元的一组 SQL 语句。所有这些语句都应成功完成。否则事务会运行失败。

注意：
- MySQL 中的单条语句会被打包成一个事务提交，具有原子性，但是多条语句不具有这些性质
- MySQL 会 lock 住需要使用的记录，这期间其他事务无法访问这个记录，等到使用完成后，会对这个记录解锁

事物的性质：
- Atomicity 原子性。每个事务都是一个工作单元，不管它包含多少语句。要么所有这些语句都成功执行且事物被提交，要么事务被回去所有更改被撤销
- Consistency 一致性。这意味着通过使用事务，数据库将始终保持一致的状态
- Isolation 隔离性。这意味着这些事务相互隔离，或者当有同样的数据被更改时各自受到保护，他们不会相互干扰。如果多个事务想更新相同的数据，受影响的行会被锁定，因此一次只有一个事务可以更新行
- Durability 持久性。事务产生的更改是永久的，即使遇到停电或者系统崩溃，也不会丢失更改的内容

## 创建事务

```sql
USE sql_store;

START TRANSACTION;  -- 显式开启事务
-- 第一步
INSERT INTO orders (customer_id, order_date, status)
VALUES (1, '2019-01-01', 1);
-- 第二步
INSERT INTO order_items
VALUES (LAST_INSERT_ID(), 1, 1, 1);

COMMIT;  
```

- 如果第二步运行失败，第一步做的更改会自动取消
- 使用 COMMIT 进行提交；使用 ROLLBACK 进行回滚

## 并发和锁定

其实事务就是对其中 SQL 语句所使用的数据上了一把锁。两个用户执行下述代码，后执行的会等待先执行的执行完毕，才修改数据库内容

```sql
USE sql_store;

START TRANSACTION;

UPDATE customers
SET points = points + 10
WHERE customer_id = 1;

COMMIT;
```

## 并发问题

### 丢失更新 lost updates

当两个事务尝试更新相同的数据并且没有上锁时，就会发生这种情况。较晚提交的事务会覆盖较早事务做出的更改

例如：一个事务想要更新某个的用户积分，而另一个事务想要更新这个用户的住址。如果两个事务同时更新，会出现其中更新失败的情况。

默认情况下，MySQL 会使用锁定机制。防止两个事务同时更新同样的数据，这样所有的更新都会完成

### 脏读 dirty reads

脏读就是一个事务读取了尚未被提交的数据

为了解决这个何题。我们需要为事务建立隔离级别，这样事务修改的数据不会立马被其他事务读取

标准的 SQL 定义了4个事务隔离级别，其中一个就是 **读已提交**

当我们事务使用这个隔离级别时，那个事务只能读取已提交的数据，这样就避免了脏读

### 不可重复读 non-repeating reads

在同一个事务中读取数据，但是出现了不同的结果

### 幻读 phantom reads

在同一个事务中读取数据，并作出处理，但是另一个事务对数据做出了更改


总结：事务之间会相互影响，导致无法达到理想结果

## 事务隔离级别

四种隔离级别能够处理的并发问题：
- 读未提交隔离级别 `READ UNCOMMITTED`：无法解决上述并发问题
- 读已提交隔离级别 `READ COMMITTED`：解决脏读
- 可重复读隔离级别 `REPEATABLE READ`：解决脏读、丢失更新、不可重复读
- 序列化隔离级别 `SERIALIZABLE`：全部解决

在 MySQL 中，默认的事务隔离级别是 **可重复读取**，大多数情况下选择默认设定就行

查看当前的事务隔离级别

```sql
SHOW VARIABLES LIKE 'transaction_isolation'
```

更改当前的事务隔离级别

```sql
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

## 死锁

死锁就是当不同事务均因握住了别的事务需要的“锁”而无法完成的情况。所以两个事物都一直在等待对方，并永远没法释放锁

举例：两个用户以相反的顺序更新记录，一般会陷入死锁



